# 快速幂模板

```
int quickPow(int a,int b){
    int s = 1;
    while(b){
        if(b&1){
            s=(s*a)%mod;
        }
        a= (a*a)%mod;
        b>>=1;
    }
    return s%mod;
}

```
对以上代码进行几点说明：

1. a^b次方中，可以将b二进制化，这也是为什么b&1即判断b当前的最低位是否为1
2. a自然迭代a*a,每次b二进制位为1时，证明有对应的a进行相乘，这样速度会大大提升
3. 举个例子：2^127次方，常规方法求幂，最简单是累乘，或者变成偶数乘即每次乘2^2 迭代，但是如果使用二进制的思想，即是2^1 * 2^2 *2^4 * 2^8 * 2^16 * 2^32 * 2^64 只需7次，极大压缩了迭乘量。